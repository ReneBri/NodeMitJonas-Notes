Express Notes:  
    Express is a minimal Node js framework, providing a higher level of abstraction.

    Express is the most popular Node framework.

    It contains a robust set of features including: complex routing, easier handling of requests and responses, middleware, serverside rendering, etc.

    It allows for fast development of Nodejs applications.

    Express allows us to easily organise our project into the MVC architecture. MVC stands for model view controller..... More on that later.

    It is convention to keep all the Express files inside an app.js.

    One thing to keep in mind when making API's is status codes. See if they change automatically when doing different requests.

    When thinking about using bigger projects think about how we can make all the code look the same.... Always use single quotes, etc.

    Using certain Express methods can automatically set headers such as 'Content-Type' to the correct type. For example using the .json() and sending a regular js object will set the header { 'Content-Type': 'json/application' }.


51. A higher level API conversation & REST architecture:
    API stands for Application Programming Interface. 
    
    On a high level, its basically a piece of software which can be used by another piece of software, in order for the applications to talk to eachother. 

    We have been using API's in a web API context but thats not the only form of API there is. The 'Application' part of API can refer to:  
        Node.js' fs or http APIs('node apis')
        Browsers DOM JavaScript API 
        With OOP, when exposing methods to the public, we're creating an API 
        Basically any modules we create outside of the main app page, could count as an api 
    
    REST Architecture:
        This stands for REpresentational State Transfer.

        This is basically a protocol for building an API, which makes it easy to consume.

        Having a standard like REST makes it easier for us users to consume this API 

        To build a RESTful API, we need to follow a could of principles: 
            We need to seperate the API into logical resources 
            We need to expose structured, resource-based URLs 
            Use the correct http methods, for example GET or POST etc 
            Must send data as JSON (usually)
            Must be stateless??

        Resources: 
            The key abstraction of information in REST is a resource. Therefor all the data we want to share with the API should be divided into logical resources. A resource is an object or representation of something, which has data associated to it. Any informatino can be named a resource. For example Tours or Users or Reviews.

        Expose structured, resource based URLs: 
            You need to make available the data, using some structured URL's that the client can make requests to. For example: https://www.natours.com/addNewTour - The 'addNewUser' here is called the 'endpoint'. This example of an endpoint is a bad example though. WE SHOULD NEVER USE A VERB IN IT. only use '/tours' and then use a POST request on that endpoint. It is common convention not to use the singular such as '/tour'.
            
        Use http methods: 
            GET, POST, PUT, PATCH, DELETE. You know how it goes.

            For actions which are not CRUD we need to get creative with the endpoints such as search or login.

            Using two resources at the same time: for eample '/getToursByUser' would translate to 'GET /users/3/tours' or 'DELETE /users/3/tours/9'. 

        Send data in JSON: 
            Not just related to js. 
            Good for both humans and machines. 
            All keys in the value pair must be strings.
            One responds standard is called JSend - this is where you create a js object and add a status value pair declaring wether is succeded or failed.

        Be Stateless: 
            In a stateless RESTful API all state is handled on the client and not on the server. This means that each req must contain ALL the info neccessary to process a certain request. The server should NOT have to remember the previous requests.

            Example of state is - loggedin / currentpage.


58. Middleware and the Request-Response Cycle 
    The essence of Express development is to understand and use the request-response cycle.

    To start the request-response cycle our Express app receives a request when someone hits our server. For which it will then create a request and response object. The client only sends a http/json request from the browser and Express converts that into an object. That data will then be used and processed in order to send back a meaningful response.

    In order to process that req, res object data in Express, we use something called middleware. Middleware is anything that can manipulate these objects. Or really execute any other code what we like. Middleware doesn't always have to be about the req or res object but it is usually mostly about the request.

    It is called middleware because it is software that executes in between this req-res cycle. In Express, EVERYTHING is a middleware, even our route definitions. Setting a http header, a loggin function or body parsing are all examples of middleware.

    In more techincal terms we call all of the middleware which we use together in our app is The Middleware Stack. 

    IMORTANT!!!!! The order of the middleware as they are defined in the stack, is the order they will be executed in the thread. For example a middleware that appears first in the code will be executed before one that appears later. 

    The flow is like this: 
        Incoming request is sent from client
        => a request and response object are created by Express
        => these objects pass through the first declared middleware, after that piece of middleware finishes running, a next() function is called and it is passed to the next piece of middleware. Each peice of middleware has this next() function, the next() is available alongside the (req, res, next) parameters when creating a function.
        => It does this step by step until we reach the last piece of middleware where instead of next() we should use res.send(). The last middleware function is usually a route handler.

    IMPORTANT! So app.use() applies to a request coming in EVERYTIME a request comes in. app.get(), etc, applies only to a request on a specific route and anything not defined inside any of these runs on the single thread upon begining our instance of Node!

    CODE ORDER MATTERS IN EXPRESS! ONCE THE RESPONSE IS SENT THE CODE STOPS RUNNING!

    Morgan is a logging tool which we will use in our app.

    Hnadlers can also be called controllers

62. Creating and Mounting Multiple Routers  
    Let's say we want to create one seperate router for each of our resources. '/api/v1/tours' and '/api/v1/users'. 

    Before this we used the app.route for both of them. That put both of them on the same router, that being the app object. But if we want to split these into seperate files then the best thing to do is create one router for each of the resourses.

    To declare an individual router we do this: 
        const tourRouter = express.Router();

    express.Router returns a new router object. This object is actually middleware.

    Then to use that router we must tell our app to use it... suprisingly enough: 
        app.use('/api/v1/tours', tourRouter);

    Then once that is declared we change the app.route('/api/v1/tours') to tourRouter.route('/').get(getAllTours); etc.

    We declare them in this order: 
        1. const tourRouter = express.Router();
        2. tourRouter.route('/').etc()
        3. app.use('/api/v1/tours', tourRouter)

    We declare them in this order because the first piece of code the request actually hits is the app.use. So if we do not declare these other routes/functions/objects before calling this app.use() method, an error will be thrown.

    Step 3 - using the app.use() to call the router is called mounting a router.

    Doing this basically creates a sub-application for each of these resourses.

    Also, we should create a server.js file. That is where our application starts and then everythin that has to do with the middleware goes into the app.js 

    So for this project so far he just has us use the app.listen in the server file and we export the app from the app.js BUT other things we keep in there, which are not related to express but still related to our application are: database configs, error handling stuff or environment variables.

    The server file looks like this: 

    //////////////////////////////////////////////////////////////////////////////

    const app = require('./app');

    const port = 3000;

    app.listen(port, () => {
        console.log(`App now listening on port ${port}`);
    });

    //////////////////////////////////////////////////////////////////////////////

    After this the root file of our app has now changed from app.js to server.js. So run Nodemon accordingly or set up an npm script. 

    The request flow now goes like this: 
        server.js => 
        app.js => 
        hits the router => 
        goes through controllers => 
        ends with send from the controllers.

    